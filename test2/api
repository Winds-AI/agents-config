#!/usr/bin/env bash
# api - OpenAPI search tool for coding agents
# Usage: ./api search <keyword>
#        ./api show <path-or-operationId>
#        ./api list [--tag=TAG]
#        ./api refresh
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/config.toml"
CACHE_DIR="$SCRIPT_DIR/cache"

# ── Colors ────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

method_color() {
  case "$1" in
    GET|get)       printf '%b' "$GREEN" ;;
    POST|post)     printf '%b' "$BLUE" ;;
    PUT|put)       printf '%b' "$YELLOW" ;;
    DELETE|delete)  printf '%b' "$RED" ;;
    PATCH|patch)   printf '%b' "$CYAN" ;;
    *)             printf '%b' "$RESET" ;;
  esac
}

# ── TOML Parser ───────────────────────────────────────────────────────
TOML_FLAT=""

toml_parse() {
  local file="$1" prefix="" line key value
  TOML_FLAT=""
  while IFS= read -r line || [[ -n "$line" ]]; do
    # strip carriage return
    line="${line%$'\r'}"
    # skip blank lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    # section header
    if [[ "$line" =~ ^\[([^]]+)\] ]]; then
      prefix="${BASH_REMATCH[1]}"
      continue
    fi
    # key = value
    if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*=[[:space:]]*(.*) ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      # strip surrounding quotes
      value="${value#\"}"
      value="${value%\"}"
      # strip inline comment (outside quotes - simple approach)
      if [[ -n "$prefix" ]]; then
        TOML_FLAT+="${prefix}.${key}=${value}"$'\n'
      else
        TOML_FLAT+="${key}=${value}"$'\n'
      fi
    fi
  done < "$file"
}

toml_get() {
  local key="$1" result
  result=$(printf '%s' "$TOML_FLAT" | grep "^${key}=" | head -1 | cut -d'=' -f2-)
  printf '%s' "$result"
}

# ── Load Config ───────────────────────────────────────────────────────
if [[ ! -f "$CONFIG_FILE" ]]; then
  echo "Error: config.toml not found. Copy config.example.toml to config.toml and fill in values." >&2
  exit 1
fi

toml_parse "$CONFIG_FILE"

ACTIVE_PROJECT="$(toml_get "active_project")"
ACTIVE_ENV="$(toml_get "active_env")"

cfg_get() {
  toml_get "projects.${ACTIVE_PROJECT}.envs.${ACTIVE_ENV}.${1}"
}

OPENAPI_URL="$(cfg_get "openapi_url")"
if [[ -z "$OPENAPI_URL" ]]; then
  echo "Error: openapi_url not set for project=$ACTIVE_PROJECT env=$ACTIVE_ENV" >&2
  exit 1
fi

# ── Cache Management ──────────────────────────────────────────────────
mkdir -p "$CACHE_DIR"
CACHE_FILE="$CACHE_DIR/${ACTIVE_PROJECT}-${ACTIVE_ENV}-openapi.json"

fetch_spec() {
  echo "Fetching OpenAPI spec from $OPENAPI_URL ..." >&2
  if ! curl -sSf "$OPENAPI_URL" -o "$CACHE_FILE" 2>/dev/null; then
    echo "Error: Failed to fetch OpenAPI spec from $OPENAPI_URL" >&2
    rm -f "$CACHE_FILE"
    exit 1
  fi
  # Validate it's JSON
  if ! jq empty "$CACHE_FILE" 2>/dev/null; then
    echo "Error: Fetched spec is not valid JSON" >&2
    rm -f "$CACHE_FILE"
    exit 1
  fi
  echo "Spec cached at $CACHE_FILE" >&2
}

ensure_spec() {
  if [[ ! -f "$CACHE_FILE" ]]; then
    fetch_spec
  fi
}

# ── Subcommands ───────────────────────────────────────────────────────

cmd_search() {
  local keyword="$1"
  ensure_spec
  jq -r --arg kw "$keyword" '
    .paths // {} | to_entries[] |
    .key as $path |
    .value | to_entries[] |
    select(.key | test("get|post|put|delete|patch|head|options")) |
    .key as $method |
    .value as $op |
    {
      method: ($method | ascii_upcase),
      path: $path,
      summary: ($op.summary // ""),
      operationId: ($op.operationId // ""),
      description: ($op.description // ""),
      tags: (($op.tags // []) | join(", "))
    } |
    select(
      (.path | ascii_downcase | contains($kw | ascii_downcase)) or
      (.summary | ascii_downcase | contains($kw | ascii_downcase)) or
      (.operationId | ascii_downcase | contains($kw | ascii_downcase)) or
      (.description | ascii_downcase | contains($kw | ascii_downcase))
    ) |
    "\(.method)\t\(.path)\t\(.summary)\t\(.operationId)\t\(.tags)"
  ' "$CACHE_FILE" | while IFS=$'\t' read -r method path summary opid tags; do
    local color
    color="$(method_color "$method")"
    printf '%b%-7s%b %s' "$color" "$method" "$RESET" "$path"
    [[ -n "$summary" ]] && printf '  %b%s%b' "$DIM" "$summary" "$RESET"
    [[ -n "$opid" ]] && printf '  %b(id: %s)%b' "$DIM" "$opid" "$RESET"
    [[ -n "$tags" ]] && printf '  %b[%s]%b' "$DIM" "$tags" "$RESET"
    printf '\n'
  done
}

cmd_list() {
  local tag_filter=""
  for arg in "$@"; do
    if [[ "$arg" =~ ^--tag=(.+) ]]; then
      tag_filter="${BASH_REMATCH[1]}"
    fi
  done
  ensure_spec
  jq -r --arg tag "$tag_filter" '
    .paths // {} | to_entries[] |
    .key as $path |
    .value | to_entries[] |
    select(.key | test("get|post|put|delete|patch|head|options")) |
    .key as $method |
    .value as $op |
    {
      method: ($method | ascii_upcase),
      path: $path,
      summary: ($op.summary // ""),
      tags: (($op.tags // []) | join(", "))
    } |
    select(
      if $tag == "" then true
      else (.tags | ascii_downcase | contains($tag | ascii_downcase))
      end
    ) |
    "\(.method)\t\(.path)\t\(.summary)\t\(.tags)"
  ' "$CACHE_FILE" | while IFS=$'\t' read -r method path summary tags; do
    local color
    color="$(method_color "$method")"
    printf '%b%-7s%b %s' "$color" "$method" "$RESET" "$path"
    [[ -n "$summary" ]] && printf '  %b%s%b' "$DIM" "$summary" "$RESET"
    [[ -n "$tags" ]] && printf '  %b[%s]%b' "$DIM" "$tags" "$RESET"
    printf '\n'
  done
}

cmd_show() {
  local target="$1"
  ensure_spec

  # Try to find by path first, then by operationId
  local found
  found=$(jq -r --arg t "$target" '
    .paths // {} | to_entries[] |
    .key as $path |
    .value | to_entries[] |
    select(.key | test("get|post|put|delete|patch|head|options")) |
    select(
      $path == $t or
      ($path | ascii_downcase) == ($t | ascii_downcase) or
      (.value.operationId // "" | ascii_downcase) == ($t | ascii_downcase)
    ) |
    {method: (.key | ascii_upcase), path: $path, op: .value}
  ' "$CACHE_FILE")

  if [[ -z "$found" ]]; then
    echo "No endpoint found matching: $target" >&2
    echo "Hint: use './api search $target' to find endpoints." >&2
    exit 1
  fi

  # Display each matching endpoint
  printf '%s' "$found" | jq -c '.' | while IFS= read -r entry; do
    local method path summary description opid tags
    method=$(printf '%s' "$entry" | jq -r '.method')
    path=$(printf '%s' "$entry" | jq -r '.path')
    summary=$(printf '%s' "$entry" | jq -r '.op.summary // ""')
    description=$(printf '%s' "$entry" | jq -r '.op.description // ""')
    opid=$(printf '%s' "$entry" | jq -r '.op.operationId // ""')
    tags=$(printf '%s' "$entry" | jq -r '(.op.tags // []) | join(", ")')

    local color
    color="$(method_color "$method")"
    printf '\n%b%b%s %s%b\n' "$BOLD" "$color" "$method" "$path" "$RESET"
    [[ -n "$summary" ]] && printf '%bSummary:%b %s\n' "$BOLD" "$RESET" "$summary"
    [[ -n "$description" ]] && printf '%bDescription:%b %s\n' "$BOLD" "$RESET" "$description"
    [[ -n "$opid" ]] && printf '%bOperation ID:%b %s\n' "$BOLD" "$RESET" "$opid"
    [[ -n "$tags" ]] && printf '%bTags:%b %s\n' "$BOLD" "$RESET" "$tags"

    # Parameters
    local params
    params=$(printf '%s' "$entry" | jq -r '
      .op.parameters // [] | if length == 0 then empty else
        "  " + (
          [.[] | "\(.name) (\(.in)) - \(.schema.type // "any")\(if .required then " [required]" else "" end)\(if .description then " -- " + .description else "" end)"]
          | join("\n  ")
        )
      end
    ')
    if [[ -n "$params" ]]; then
      printf '%bParameters:%b\n%s\n' "$BOLD" "$RESET" "$params"
    fi

    # Request body schema
    local body_schema
    body_schema=$(printf '%s' "$entry" | jq -r '
      .op.requestBody.content // {} |
      (
        .["application/json"].schema //
        (to_entries | first // {value: null} | .value.schema) //
        null
      ) |
      if . == null then empty
      elif .properties then
        [.properties | to_entries[] |
          "\(.key): \(.value.type // .value["\u0024ref"] // "object")\(if (.value.description // "") != "" then " -- " + .value.description else "" end)"
        ] | "  " + join("\n  ")
      elif .["$ref"] then
        "  $ref: \(.["$ref"])"
      else
        "  type: \(.type // "unknown")"
      end
    ')
    if [[ -n "$body_schema" ]]; then
      printf '%bRequest Body:%b\n%s\n' "$BOLD" "$RESET" "$body_schema"
    fi

    # Response schemas
    local responses
    responses=$(printf '%s' "$entry" | jq -r '
      .op.responses // {} | to_entries[] |
      "\(.key): \(.value.description // "")" +
      (
        (.value.content // {} | .["application/json"].schema // null) as $s |
        if $s == null then ""
        elif $s.properties then
          "\n    " + ([$s.properties | to_entries[] | "\(.key): \(.value.type // "object")"] | join(", "))
        elif $s["$ref"] then
          "\n    $ref: \($s["$ref"])"
        elif $s.type == "array" and $s.items then
          "\n    array of: \($s.items.type // $s.items["$ref"] // "object")"
        else
          "\n    type: \($s.type // "unknown")"
        end
      )
    ')
    if [[ -n "$responses" ]]; then
      printf '%bResponses:%b\n' "$BOLD" "$RESET"
      printf '%s\n' "$responses" | while IFS= read -r line; do
        printf '  %s\n' "$line"
      done
    fi

    printf '%b────────────────────────────────────%b\n' "$DIM" "$RESET"
  done
}

cmd_refresh() {
  fetch_spec
  echo "OpenAPI spec refreshed."
}

# ── Main ──────────────────────────────────────────────────────────────
usage() {
  cat <<EOF
Usage: ./api <command> [args]

Commands:
  search <keyword>     Search endpoints by path, summary, description, operationId
  show <path-or-id>    Show full details for an endpoint
  list [--tag=TAG]     List all endpoints, optionally filter by tag
  refresh              Re-fetch and cache the OpenAPI spec

Active: project=$ACTIVE_PROJECT env=$ACTIVE_ENV
EOF
  exit 1
}

if [[ $# -lt 1 ]]; then
  usage
fi

COMMAND="$1"
shift

case "$COMMAND" in
  search)
    [[ $# -lt 1 ]] && { echo "Usage: ./api search <keyword>" >&2; exit 1; }
    cmd_search "$1"
    ;;
  show)
    [[ $# -lt 1 ]] && { echo "Usage: ./api show <path-or-operationId>" >&2; exit 1; }
    cmd_show "$1"
    ;;
  list)
    cmd_list "$@"
    ;;
  refresh)
    cmd_refresh
    ;;
  *)
    echo "Unknown command: $COMMAND" >&2
    usage
    ;;
esac
